We’re going to use an Azure Container Instance to host an API that serves our machine learning model for predictions. The model is stored as a Tensorflow SavedModel, and outputs the predicted sentiment (positive/negative) for an input sentence. The API should have three endpoints (for simplicity, let both be GET methods):
/status: Should return a short message if the API is reachable and working.
/predict: Runs a sentiment prediction. The endpoint should be able to accept a list of sentences.
/refresh: Loads a newer model from Azure Storage. 
The exercise instructions are not complete, mostly on purpose. If you get stuck, ask Snorre or a fellow student. 
Starting the API
Use the simplest FastAPI example from the FastAPI documentation to create the first /status endpoint. 
Include the “logging” module and put the following line after declaring the FastAPI app:
logging.basicConfig(filename="log.log", level=logging.INFO)
This output all logs to a file. You log in the same way as you do with a print, by using logging.info(“This is info”), logging.warning(“This is warning”), logging.error(“This in an error”). 
Write a Dockerfile for your program, along with a requirements.txt file. Note you will be updating this Dockerfile throughout the microproject.
Use a bind mount to maintain a local copy of the generated 
Loading the model
Ask Snorre to kindly upload the model to Slack, if he hasn’t already. Take a look at the model format, and skim through the Tensorflow SavedModel documentation to get an idea of how to load it.
We will eventually load the model from Azure Storage as a zipped folder. Figure out how to use Python to unzip the folder.
Create the /predict endpoint.
Connecting to Azure Storage
Create (or reuse) an Azure Storage container and upload the zipped model there. We will pretend like some other application regularly updates the model in the same location.
Figure out how to connect to Azure Storage and retrieve the file. You should Google something along the lines of “Azure Storage Python SDK”. 
Create the /refresh endpoint. 
(Note that hardcoding credentials into application code is generally a bad idea, but okay for the purpose of this microproject)
Testing!
If you haven’t already, run the container and verify that all endpoints work as expected. 
Deploy to Azure!
By now you have a built image locally with your awesome API. Time to deploy it to the cloud, with Azure Container Instance! ACI sets up a URL  There are several steps to this. How about starting by checking out the Azure Container Instance tutorials (Lenker til en ekstern side.)?
Final testing and configuration
Well done on coming so far! Use the logs generated by your application (Lenker til en ekstern side.) (you’ve put in smart logs make it easier for yourself, right?) to figure out what (if anything) goes wrong when testing all the endpoints.